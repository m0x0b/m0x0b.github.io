<!DOCTYPE html>

<html lang="en">
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="gallery.css" />
    <title>m0x0b</title>
  </head>

  <body>

    <!-- div that will hold our WebGL canvas -->
    <div id="canvas"></div>

    <div id="content">
      <h1 id="title">NFT Collection 0, 1615481914</h1>

      <!-- drag slider -->
      <div id="planes">

        <a href="https://opensea.io/assets/0x495f947276749ce646f68ac8c248420045cb7b5e/71856514976474579381482599745109413688155812257082282086702350858602627989505">
        <div class="plane-wrapper">
          <p class="plane-title a">Still and Life 2</p>
          <p></p>
          <p class="plane-title b">
            Content Loss: 0<br />
            Hardware: NVIDIA Tesla P100<br />
            Epoch: 1615531694<br />
          </p>
          <div class="plane">
            <img src="veins0com.png" data-sampler="planeTexture" crossorigin />
          </div>
        </div>
        </a>

        <a href="https://opensea.io/assets/0x495f947276749ce646f68ac8c248420045cb7b5e/71856514976474579381482599745109413688155812257082282086702350864100186128385">
        <div class="plane-wrapper">
            <p class="plane-title a">Still and Life 3</p>
            <p></p>
            <p class="plane-title b">
              Content Loss: 0<br />
              Hardware: NVIDIA Tesla P100<br />
              Epoch: 1615540505<br />
            </p>
            <div class="plane">
              <img src="veins1com.png" data-sampler="planeTexture" crossorigin />
            </div>
        </div>
        </a>

        <a href="https://opensea.io/assets/0x495f947276749ce646f68ac8c248420045cb7b5e/71856514976474579381482599745109413688155812257082282086702350867398721011713">
        <div class="plane-wrapper">
          <p class="plane-title a">Still and Life 4</p>
          <p class="plane-title b">
            Content Loss: 0<br />
            Hardware: NVIDIA Tesla P100<br />
            Epoch: 1615688974<br />
          </p>
          <div class="plane">
            <img src="viable0com.png" data-sampler="planeTexture" crossorigin />
          </div>
        </div>
        </a>

        <a href="https://opensea.io/assets/0x495f947276749ce646f68ac8c248420045cb7b5e/71856514976474579381482599745109413688155812257082282086702350869597744267265">
        <div class="plane-wrapper">
          <p class="plane-title a">Still and Life 5</p>
          <p class="plane-title b">
            Content Loss: 0<br />
            Hardware: NVIDIA Tesla P100<br />
            Epoch: 1615692811<br />
          </p>
          <div class="plane">
            <img src="viable1com.png" data-sampler="planeTexture" crossorigin />
          </div>
        </div>
      </div>
      </a>

      <div id="drag-tip">Drag to view</div>
    </div>
  </body>

  <script>
    window.onload = function() {
        if(!window.location.hash) {
            window.location = window.location + '#loaded';
            window.location.reload();
        }
    }
  </script>

  <script id="slider-planes-vs" type="x-shader/x-vertex">
    #ifdef GL_ES
    precision mediump float;
    #endif

    // default mandatory attributes
    attribute vec3 aVertexPosition;
    attribute vec2 aTextureCoord;

    // those projection and model view matrices are generated by the library
    // it will position and size our plane based on its HTML element CSS values
    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;

    // this is generated by the library based on the sampler name we provided
    // it will be used to map adjust our texture coords so the texture will fit the plane
    uniform mat4 planeTextureMatrix;

    // texture coord varying that will be passed to our fragment shader
    varying vec2 vTextureCoord;

    void main() {
        // apply our vertex position based on the projection and model view matrices
        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);

        // varying
        // use texture matrix and original texture coords to generate accurate texture coords
        vTextureCoord = (planeTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;
    }
  </script>
  <script id="slider-planes-fs" type="x-shader/x-fragment">
    #ifdef GL_ES
    precision mediump float;
    #endif

    // our texture coords varying
    varying vec2 vTextureCoord;

    // our texture sampler (see how its name matches the data-sampler attribute on our image tags)
    uniform sampler2D planeTexture;
    // our opacity uniform that goes from 0 to 1
    uniform float uOpacity;

    void main( void ) {
        // map our texture to the varying texture coords
        vec4 finalColor = texture2D(planeTexture, vTextureCoord);

        // the distance from this point to the top edge is a float from 0 to 1
        float distanceToTop = distance(vec2(vTextureCoord.x, 1.0), vTextureCoord);

        // calculate an effect that goes from 0 to 1 depenging on uOpacity and distanceToTop
        float spreadFromTop = clamp((uOpacity * (1.0 - distanceToTop) - 1.0) + uOpacity * 2.0, 0.0, 1.0);

        // handle pre-multiplied alpha on rgb values and use spreadFromTop as alpha.
        finalColor = vec4(vec3(finalColor.rgb * spreadFromTop), spreadFromTop);

        // this is it
        gl_FragColor = finalColor;
    }
  </script>

  <script id="distortion-vs" type="x-shader/x-vertex">
    #ifdef GL_ES
    precision mediump float;
    #endif

    // default mandatory attributes
    attribute vec3 aVertexPosition;
    attribute vec2 aTextureCoord;

    // our displacement texture matrix uniform
    uniform mat4 displacementTextureMatrix;

    // mouse position and direction uniforms
    uniform vec2 uMousePos;
    uniform float uDirection;

    // custom varyings
    varying vec2 vTextureCoord;
    varying vec2 vDispTextureCoord;
    varying vec2 vMouseTexCoords;

    void main() {
        gl_Position = vec4(aVertexPosition, 1.0);

        // varyings
        vTextureCoord = aTextureCoord;
        vDispTextureCoord = (displacementTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;

        // we will handle our mouse coords here for better performance
        // get our texture coords for both directions
        vec2 mouseHorizontalTexCoords = (uMousePos + 1.0) / 2.0;
        mouseHorizontalTexCoords.y = 0.5;

        vec2 mouseVerticalTexCoords = (uMousePos + 1.0) / 2.0;
        mouseVerticalTexCoords.x = 0.5;

        // use the right value for the right direction
        vMouseTexCoords = mix(mouseHorizontalTexCoords, mouseVerticalTexCoords, uDirection);
    }
  </script>
  <script id="distortion-fs" type="x-shader/x-fragment">
    #ifdef GL_ES
    precision mediump float;
    #endif

    // varyings
    varying vec2 vTextureCoord;
    varying vec2 vDispTextureCoord;
    varying vec2 vMouseTexCoords;

    // our render texture is basically what's being drawn in our canvas
    uniform sampler2D uRenderTexture;
    // the displacement texture we've loaded into our shader pass
    uniform sampler2D displacementTexture;

    // all our uniforms
    uniform float uDragEffect;
    uniform vec2 uMousePos;
    uniform vec2 uOffset;
    uniform float uDirection;
    uniform vec3 uBgColor;

    void main( void ) {
        vec2 textureCoords = vTextureCoord;

        // repeat and offset our displacement map texture coords for both slider directions
        vec2 horizontalPhase = fract(vec2(vDispTextureCoord.x + uOffset.x, vDispTextureCoord.y + (uOffset.y / 3600.0)) / vec2(1.0, 1.0));
        vec2 verticalPhase = fract(vec2(vDispTextureCoord.x * (uOffset.x / 3600.0), vDispTextureCoord.y + uOffset.y) / vec2(1.0, 1.0));

        // use the correct repeated and offseted texture coords
        vec2 phase = mix(horizontalPhase, verticalPhase, uDirection);
        vec4 displacement = texture2D(displacementTexture, phase);

        // use our varying mouse texture coords
        vec2 mouseTexCoords = vMouseTexCoords;

        float distanceToMouse = distance(mouseTexCoords, textureCoords);

        // calculate an effect that goes from 0 to 1 depenging on uDragEffect and distanceToMouse
        float spreadFromMouse = clamp((uDragEffect * (1.0 - distanceToMouse) - 1.0) + uDragEffect * 2.0, 0.0, 1.0);

        // calculate our fish eye like distortions
        vec2 fishEye = (vec2(textureCoords - mouseTexCoords).xy) * pow(distanceToMouse, 3.0);

        // add a displacement based on our map and our time uniform
        float displacementEffect = displacement.r * 1.25;

        // spread our fish eye and displacement effects from our mouse
        // calculate for both directions
        vec2 horizontalTexCoords = textureCoords;
        horizontalTexCoords.x -= spreadFromMouse * fishEye.x * displacementEffect / 2.0;
        horizontalTexCoords.y += spreadFromMouse * fishEye.y * displacementEffect * 3.0;

        vec2 verticalTexCoords = textureCoords;
        verticalTexCoords.x += spreadFromMouse * fishEye.x * displacementEffect * 3.0;
        verticalTexCoords.y -= spreadFromMouse * fishEye.y * displacementEffect / 2.0;

        // use the right value for the right direction
        textureCoords = mix(horizontalTexCoords, verticalTexCoords, uDirection);


        // get our final colored and BW vec4
        vec4 finalColor = texture2D(uRenderTexture, textureCoords);
        float grey = dot(finalColor.rgb, vec3(0.299, 0.587, 0.114));
        vec4 finalGrey = vec4(vec3(grey), 1.0);

        // mix our both vec4 based on our spread value
        finalColor = mix(finalColor, finalGrey, spreadFromMouse * finalColor.a);

        float spreadFromMouseAdjusted = spreadFromMouse / sqrt(2.0);

        // apply a grey background where we don't have nothing to draw
        finalColor = mix(vec4(uBgColor.r * spreadFromMouseAdjusted / 255.0, uBgColor.g * spreadFromMouseAdjusted / 255.0, uBgColor.b * spreadFromMouseAdjusted / 255.0, spreadFromMouseAdjusted), finalColor, finalColor.a);

        gl_FragColor = finalColor;
    }
  </script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/2.2.0/anime.min.js"></script>
  <script src="https://www.curtainsjs.com/build/curtains.min.js"></script>
  <script src="gallery.js"></script>
</html>
